% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/auto_boxjen.r
\name{karma.hillclimbing}
\alias{karma.hillclimbing}
\title{Combinatorial optimisation local search algorithm (modified hill-climbing) for ARIMA model selection - part of the model optimisation API.}
\usage{
karma.hillclimbing(sol, y, ac_criterion = F, xreg = NULL, metric = "MAPE",
  cv = "out", diffs = 0, max_rep = 1, optimiser = "semi-stochastic",
  fixed = F, test_pct = 20, test_type = "percentage", mutations = F,
  plot = T)
}
\arguments{
\item{sol}{ARIMA order in the form of a candidate solution to the optimisation problem.}

\item{y}{A univariate time-series vector; type <numeric> or <ts>.}

\item{ac_criterion}{Aucocorrelation / Partial autocorrelation test flag on/off; An optional optimisation constraint which applies portmanteau test on every candidate solution and rejects solutions that do not improve AC/PAC.}

\item{xreg}{Optional vector or matrix of exogenous regressors; see documentation for Arima(), package 'forecast'.}

\item{metric}{Choose a model validation metric that will be used as the main optimisation criterion during model selection.}

\item{cv}{Choose cross-validation dataset to be used during model selection; "out": Performance of out-of-sample forecast (classic train/test split) will be used for model validation; "in": Performance of in-sample forecast (classic parametric regression type of validation) will be used for model validation.}

\item{diffs}{Differencing step: Indicates whether the candidate solution needs to be differenced for stationarity (and to what degree); {0,1,...,n}; type <int>.}

\item{max_rep}{For karma-search: Maximum number of iterations without improvement before the algorithm converges naturally (reached a global or local optimum).}

\item{optimiser}{Option on the "neighbourhood function" of the optimisation algorithm; "semi-stochastic": Once a neighbourhood region (of either AR and MA terms) has been selected randomly, the candidate solutions are chosen deterministically; "stochastic": Once a neighbourhood region (of either AR and MA terms) has been selected randomly, the candidate neighbour solutions are chosen stochastically.}

\item{fixed}{Fixed term flag. Indicate whether the fixed term option in Arima() needs to be switched on during model selection; {T, F}; type <logical>.}

\item{test_pct}{Percentage of train-test split in cross-validation (e.g. 70-30).}

\item{test_type}{Train-test split type, i.e. percentage or fixed window; "percentage": test_pct = 12 will be read as the 12 of the length of the series; "window": test_pct = 12 will be read as the 12 last time points (e.g. months) of the series.}

\item{mutations}{Optional neighbourhood operator; Mutations flag {T, F}: whether or not to apply random "mutations" (term borrowed from evolutionary algorithms) on a candidate solution when the optimiser is about to converge (a way to escape local optima - works somewhat like an inverse simulated annealing).}

\item{ar_terms}{Autoregressive terms; can be in the form of a vector (fixed_ = FALSE) or a list of vectors (fixed_ = TRUE).}

\item{ma_terms}{Move average terms; can be in the form of a vector (fixed_ = FALSE) or a list of vectors (fixed_ = TRUE).}

\item{max_conv}{For karma.boxjenkins(): Maximum number of iterations without improvement before the algorithm converges forcefully (stuck to a local optimum).}

\item{max_iter}{For karma.boxjenkins(): Maximum number of iterations without improvement before the algorithm converges naturally (reached a global or local optimum).}
}
\value{
List with optimisation results.
}
\description{
Combinatorial optimisation local search algorithm (modified hill-climbing) for ARIMA model selection - part of the model optimisation API.
}
\examples{
kfit = auto.boxjen(y, method = "karma", optimiser = "stochastic", mutations = T, max_rep = 15, max_ar = 4, max_ma = 4)
tmp = karma.hillclimbing( sol = kfit$solopt, y = y, fixed=T, diffs = kfit$model_terms[[2]], optimiser = "stochastic")
tmp = karma.hillclimbing( sol = tmp[[2]], y = y, fixed=T, diffs = kfit$model_terms[[2]],  optimiser = "stochastic")
}
\seealso{
\code{\link{tseries}}, \code{\link{forecast}}
}

